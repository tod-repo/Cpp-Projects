/*****************************************************************************
 *  @brief	STL初识
 * 
	长久以来，软件界一直希望建立一种可重复利用的东西
	C++的面向对象和泛型编程思想，目的就是复用性的提升
	大多情况下，数据结构和算法都未能有一套标准, 导致被迫从事大量重复工作
	为了建立数据结构和算法的一套标准, 诞生了STL

	STL(Standard Template Library, 标准模板库)，是一套功能强大的 C++ 模板类，
	提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构
	
	STL 从广义上分为 : 容器(container) 算法(algorithm) 迭代器(iterator)
	容器和算法之间通过迭代器进行无缝连接。
	STL 几乎所有的代码都采用了模板类或者模板函数

	STL六大组件
		分别是 : 容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器

		容器：各种数据结构，如vector、list、deque、set、map等, 用来存放数据。
		算法：各种常用的算法，如sort、find、copy、for_each等
		迭代器：扮演了容器与算法之间的胶合剂。
		仿函数：行为类似函数，可作为算法的某种策略。
		适配器：一种用来修饰容器或者仿函数或迭代器接口的东西，如stack、queue。
		空间配置器：负责空间的配置与管理。

STL中容器、算法、迭代器
	容器： 置物之所也
		STL容器就是将运用最广泛的一些数据结构实现出来
		常用的数据结构：数组, 链表, 树, 栈, 队列, 集合, 映射表 等

		容器，可理解为一些模板类的集合，但和普通模板类不同的是，容器中封装的是组织数据的方法（也就是数据结构）。

		这些容器分为序列式容器和关联式容器两种 :
	​		序列式容器 : 
				强调值的排序，序列式容器中的每个元素均有固定的位置。
				（数组和链表都属于序列，但分支结构不是）
			关联式容器 : 
				二叉树结构，各元素之间没有严格的物理上的顺序关系

	STL 提供有 3 类标准容器：
		序列容器、排序容器和哈希容器，其中后两类容器有时也统称为关联容器。
		
		序列容器：
			主要包括 vector 向量容器、list 列表容器以及 deque 双端队列容器。
			之所以被称为序列容器，是因为元素在容器中的位置同元素的值无关，即容器不是排序的。
			将元素插入容器时，指定在什么位置，元素就会位于什么位置。
		
		排序容器（关联容器）：
			包括 set 集合容器、multiset多重集合容器、map映射容器以及 multimap 多重映射容器。
			排序容器中的元素默认是由小到大排序好的，即便是插入元素，元素也会插入到适当位置。
			所以关联容器在查找时具有非常好的性能。

		哈希容器（关联容器）：
			C++ 11 新加入 4 种关联式容器，分别是 unordered_set 哈希集合、unordered_multiset 哈希多重集合、
			unordered_map 哈希映射以及 unordered_multimap 哈希多重映射。
			和排序容器不同，哈希容器中的元素是未排序的，元素的位置由哈希函数确定。
		
		注：以上 3 类容器的存储方式完全不同，因此使用不同容器完成相同操作的效率也大不相同。
		    所以在实际使用时，要善于根据想实现的功能，选择合适的容器。

	无论是哪种序列式容器，其存储的都是 C++ 基本数据类型（诸如 int、double、float、string 等）或使用结构体、类自定义类型的元素。
		例如，存储 int 类型元素的 vector 容器：std::vector<int> primes {2, 3, 5, 13};

	关联式容器则大不一样，此类容器在存储元素值的同时，还会为各元素额外再配备一个值（又称为“键”，
	其本质也是一个 C++ 基础数据类型或自定义类型的元素），它的功能是在使用关联式容器的过程中，如果
	已知目标元素的键的值，则直接通过该键就可以找到目标元素，而无需再通过遍历整个容器的方式。

	弃用序列式容器，转而选用关联式容器存储元素，往往就是看中了关联式容器可以快速查找、
	读取或者删除所存储的元素，同时该类型容器插入元素的效率也比序列式容器高。

	也就是说，使用关联式容器存储的元素，都是一个一个的“键值对”（ <key,value> ），这是和序列式容器最大的不同。
	此外，序列式容器中存储的元素默认都是未经过排序的，而关联式容器存储，默认会根据各元素的键值的大小做升序排序。

	注意：关联式容器所具备的这些特性，归咎于 STL 标准库在实现该类型容器时，底层选用了 「红黑树」这种数据结构来组织和存储各个键值对。
	
	///////////////
	vector、deque、list在设置回调函数时既可以用 全局函数名 也可以用 仿函数类名+() 调用
		如 sort(vec1.begin(), vec1.end(), myFunc);
		   sort(vec1.begin(), vec1.end(), myClass());
		   List1.sort(myFunc);
		   List1.sort(myClass());
	set 和 map 容器回调，如排序，是在<>里设置排序规则，set<int, ClassName> set1;
	且第二个参数只能写仿函数的类名（后面不加小括号），不能是全局函数名
	例如，像for_each算法，也是 全局函数名 也可以用 仿函数类名+() 两种方式都可以用
	//////////////


	算法：问题之解法也

		有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)

		算法分为 : 质变算法和非质变算法。
			质变算法：
				是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等

			非质变算法：
				是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等

	迭代器： 容器和算法之间粘合剂

		提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。

		每个容器都有自己专属的迭代器

		迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针

		通过迭代器访问容器元素的三种方式要掌握

	迭代器种类：
	| 种类           | 功能                                                     | 支持运算                                |
	| -------------- | -------------------------------------------------------- | --------------------------------------- |
	| 输入迭代器     | 对数据的只读访问                                         | 只读，支持++、==、！=                   |
	| 输出迭代器     | 对数据的只写访问                                         | 只写，支持++                            |
	| 前向迭代器     | 读写操作，并能向前推进迭代器                             | 读写，支持++、==、！=                   |
	| 双向迭代器     | 读写操作，并能向前和向后操作                             | 读写，支持++、--，                      |
	| 随机访问迭代器 | 读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器 | 读写，支持++、--、[n]、-n、<、<=、>、>= |

	常用的容器中迭代器种类为：双向迭代器，和随机访问迭代器，因为这俩功能比较强大


	** 各个容器常用迭代器或方法：**
		容器.begin()  //指向 第一个元素
		容器.end()   //指向 最后一个元素的后一个位置

		容器.rbegin()  //指向最后一个元素
		容器.rend()   //指向第一个元素的前一个位置

		容器.front()  //指向第一个元素
		容器.back()   //指向最后一个元素

		容器.push_back(a) //尾插
		容器.push_front(a) //头插
		容器.pop_back(a) //尾删
		容器.pop_front(a) //头删

	容器： vector   vector<数据类型> vec; //创建容器

		算法： for_each

		迭代器：vector<int>::iterator    //vector存放内置数据类型
				vector<Person>::iterator //vector存放自定义数据类型
				vector<Person *>::iterator //vector存放自定义数据类型的指针
		容器嵌套：
			vector< vector<int> > vec4; //相当于二维数组

	设置容器为只读状态：
 		遇到常量容器类型，数据不能修改，只读
 		遇到常量容器类型，使用迭代器时，必须使用常量迭代器：const_iterator


顺序存储结构：

	在计算机中用一组地址连续的 存储单元 依次存储线性表的各个 数据元素 ,称作线性表的顺序存储结构.　
		
	顺序存储结构是存储结构类型中的一种，该结构是把逻辑上相邻的 节点 存储在物理位置上相邻的 存储单元 中，
	结点之间的逻辑关系由存储单元的邻接关系来体现。由此得到的存储结构为顺序存储结构，通常顺序存储结构是借
	助于 计算机程序设计语言 （例如c/c++）的 数组 来描述的。
		
	顺序存储结构的主要优点是节省 存储空间 ，因为分配给数据的 存储单元 全用存放结点的数据
	（不考虑c/c++语言中 数组 需指定大小的情况），结点之间的逻辑关系没有占用额外的存储空间。
	采用这种方法时，可实现对结点的 随机存取 ，即每一个结点对应一个序号，由该序号可以直接计算出来结点的存储地址。
	但顺序存储方法的主要缺点是不便于修改，对结点的插入、删除运算时，可能要移动一系列的结点。
		
	优点：随机存取表中元素。
	缺点：插入和删除操作需要移动元素。

随机存储结构：

	在计算机中用一组任意的 存储单元 存储线性表的 数据元素 (这组存储单元可以是连续的,也可以是不连续的).
	它不要求逻辑上相邻的元素在物理位置上也相邻.因此它没有 顺序存储结构 所具有的弱点,但也同时失去了 顺序表 可 随机存取 的优点.
	链式存储结构特点：
	1、比 顺序存储结构 的存储密度小 (每个节点都由数据域和 指针 域组成，所以相同空间内假设全存满的话顺序比链式存储更多)。
	2、逻辑上相邻的节点物理上不必相邻。
	3、插入、删除灵活 (不必移动节点，只要改变节点中的 指针 )。
	4、查找结点时链式存储要比顺序存储慢。
	5、每个结点是由数据域和指针域组成。

 *****************************************************************************/

#include<iostream>
#include <vector>
#include<algorithm> //标准算法头文件
using namespace std;

/*****************************************************************************
 *  @brief	vector 容器
 *		STL中最常用的容器为vector，可以理解为数组，可以对容器插入，遍历等
		
		容器： vector   vector<数据类型> vec; //创建容器

		算法： for_each

		迭代器：vector<int>::iterator    //vector存放内置数据类型
				vector<Person>::iterator //vector存放自定义数据类型
				vector<Person *>::iterator //vector存放自定义数据类型的指针
		容器嵌套：
			vector< vector<int> > vec4; //相当于二维数组
			
 *****************************************************************************/

/*****************************************************************************
 *  @brief	vector存放内置数据类型
 *				vector<int> vec1;
 *****************************************************************************/
void printVec(int val)
{
	cout << val << "  ";
}
void vec_test01()
{
	cout << endl << "** vector存放内置数据类型 **" << endl;

	//创建一个vector容器，和数组类似。需要 #include <vector>
	vector<int> vec1;  //类比 19小节 的 MyArray<int> arr1
	vec1.push_back(10); //尾插
	vec1.push_back(20);
	vec1.push_back(30);
	cout << vec1[0] << endl; //10，像数组那样访问数据
	cout << vec1[1] << endl; //20
	//cout << vec1.size(); //3

	/*1、普通 for循环 遍历 vector容器  */
	cout << endl << "for循环 对 vector容器 遍历" << endl;
	for (int i = 0; i < vec1.size(); i++)
	{
		cout << vec1[i] << "  ";  //10  20  30
	}

	cout << endl << endl;


	/*2、 通过迭代器访问容器中的数据 */
	//每个容器都有自己的迭代器，迭代器是用来遍历容器中的元素。
	vector<int>::iterator itBegin = vec1.begin();  //起始迭代器，指向容器中的第一个元素
	vector<int>::iterator itEnd = vec1.end();  //结束迭代器，指向容器中的最后一个元素的后一个位置
	//vector<int>::iterator 表示 vector<int> 这种容器的迭代器类型

	cout << "起始迭代器 vec1.begin() = " << * itBegin << endl; //10，迭代器相当于指针，解引用即可

	//① while+迭代器访问的第一种遍历方式
	cout << endl << "迭代器访问的第一种遍历方式：while+迭代器 " << endl;
	while (itBegin != itEnd)
	{
		cout << *itBegin << "  ";
		itBegin++;
	}

	//② 迭代器访问的第二种遍历方式
	cout << endl << "迭代器访问的第二种遍历方式：for+迭代器 " << endl;
	for (vector<int>::iterator it = vec1.begin(); it < vec1.end(); it++) 
	{
		//迭代器it的类型就为<int>类型的指针，(*it)就是<int>类型数据
		cout << *it << "  ";
	}

	//③ 迭代器访问的第三种遍历方式：STL算法，要提前 #include<algorithm>
	cout << endl << "迭代器访问的第三种遍历方式：STL中的 for_each 算法 " << endl;
	for_each(vec1.begin(), vec1.end(), printVec); //printVec利用了回调函数
}

/*****************************************************************************
 *  @brief	vector存放自定义数据类型
 *				vector<Person13> vec2;
 *****************************************************************************/
class Person13
{
public:
	string m_Name;
	int m_Age;
	Person13(string name, int age)
	{
		m_Name = name;
		m_Age = age;
	}
};
void vec_test02()
{
	cout << endl << endl << "** vector存放自定义数据类型 **" << endl;

	//创建Person类型的容器
	vector<Person13> vec2;

	Person13 p1("孙悟空", 100);
	Person13 p2("沙和尚", 90);
	Person13 p3("八戒", 80);

	vec2.push_back(p1);
	vec2.push_back(p2);
	vec2.push_back(p3);

	/*1、 for循环遍历容器中的数据 */
	for (int i = 0; i < vec2.size(); i++)
	{
		cout << vec2[i].m_Name << "  " << vec2[i].m_Age << endl;
	}

	/*2、 通过迭代器访问容器中的数据：v_test01的三种方法仍然适用 */

	cout << endl << "迭代器访问：for+迭代器 " << endl;
	for (vector<Person13>::iterator it = vec2.begin(); it < vec2.end(); it++) 
	{
		//迭代器it就是<Person13>类型的指针，(*it)就是 <Person13>类型

		cout << (*it).m_Name << "  " << (*it).m_Age << endl; 
		//cout << it->m_Name << "  " << it->m_Age << endl;

		//注意：为什么不直接写* it.name，因为编译器会认为:这是在访问it对象的成员name然后再将它解引用
		//(*it).name是解引用指针it, 得到地址指向的对象，然后访问其成员name。
		//这是运算符优先级的知识，至于->和(*).的写法没有任何区别，功能相同，方法不同而已
	}
}

/*****************************************************************************
 *  @brief	vector存放自定义数据类型的指针 
 *				vector<Person13 *> vec3;
 *****************************************************************************/
void vec_test03()
{
	cout << endl << "** vector存放自定义数据类型的指针 **" << endl;

	//创建Person*类型的容器
	vector<Person13 *> vec3;

	Person13 p1("孙悟空", 100);
	Person13 p2("沙和尚", 90);
	Person13 p3("八戒", 80);

	vec3.push_back(&p1);
	vec3.push_back(&p2);
	vec3.push_back(&p3);

	/* 遍历容器 */
	cout << endl << "迭代器访问" << endl;

	for (vector<Person13*>::iterator it = vec3.begin(); it < vec3.end(); it++) 
	{
		//迭代器it就是<Person13 *>类型的指针，(*it)就是<Person13 *>类型

		cout << (**it).m_Name << "  " << (**it).m_Age << endl;
		//cout << (*it)->m_Name << "  " << (*it)->m_Age << endl; //两种方式均可
	}
}


/*****************************************************************************
 *  @brief	vector容器嵌套容器，就类似于二维数组
 *				vector< vector<int> > vec4;
 *****************************************************************************/
void vec_test04()
{
	cout << endl << "** 容器嵌套 **" << endl;
	//容器嵌套
	vector< vector<int> > vec4;

	//创建小容器
	vector<int> v1;
	vector<int> v2;
	vector<int> v3;

	//向小容器中添加数据
	for (int i = 0; i < 4; i++)
	{
		v1.push_back(i + 1);
		v2.push_back(i + 2);
		v3.push_back(i + 3);
	}

	//将小容器插入到大容器中
	vec4.push_back(v1);
	vec4.push_back(v2);
	vec4.push_back(v3);

	//1、普通for循环遍历嵌套容器
	cout << endl << "普通for循环遍历嵌套容器" << endl;
	for (int i = 0; i < vec4.size(); i++)
	{
		for (int j = 0; j < vec4[0].size(); j++)
		{
			cout << vec4[i][j] << "  ";
		}
		cout << endl;
	}

	//2、迭代器遍历嵌套容器
	cout << endl << "迭代器访问嵌套容器" << endl;
	for (vector< vector<int> >::iterator itBig = vec4.begin(); itBig < vec4.end(); itBig++)
	{
		//(*itBig)是<vector<int>>类型，仍为容器
		for (vector<int>::iterator itSmall = (*itBig).begin(); itSmall < (*itBig).end(); itSmall++)
		{
			cout << *itSmall << "  ";
		}
		cout << endl;
	}
}

/*****************************************************************************
 *  @brief	设置容器为只读状态：
 *		遇到常量容器类型，数据不能修改，只读
 *		遇到常量容器类型，使用迭代器时，必须使用常量迭代器：const_iterator
 * 
 *****************************************************************************/
void printVec2(const vector<int>& vec) 
{
	//遇到常量容器类型，使用迭代器时，必须使用常量迭代器：const_iterator
	//for (vector<int>::iterator it = vec.begin(); it < vec.end(); it++)//错误

	for (vector<int>::const_iterator it = vec.begin(); it < vec.end(); it++)//使用常量迭代器
	{
		//*it = 0; //错误，数据不能修改，只读
		cout << *it << " ";
	}
	cout << endl;

	for (int i = 0; i < vec.size(); i++)
	{
		//vec[i] = 0; //错误，常量容器类型，数据不能修改，只读
		cout << vec[i] << " ";
	}
	cout << endl;
}
void vec_test05()
{
	cout << endl << "** 设置容器为只读状态 **" << endl;

	vector<int> vec1;
	vec1.push_back(1);
	vec1.push_back(2);
	vec1.push_back(3);

	for (vector<int>::const_iterator it = vec1.begin(); it < vec1.end(); it++)
	{
		//*it = 0; //错误，不能给常量赋值，只读
		cout << *it << " ";
	}
	cout << endl;

	printVec2(vec1);
	

}
/*****************************************************************************
 *  @brief	main
 *
 *****************************************************************************/
int main20()
{
	//vector存放内置数据类型
	vec_test01();

	//vector存放自定义数据类型
	vec_test02();

	//vector存放自定义数据类型的指针
	vec_test03();

	//vector嵌套
	vec_test04();

	//设置容器为只读状态：常量迭代器
	vec_test05();
	
	return 0;
}
